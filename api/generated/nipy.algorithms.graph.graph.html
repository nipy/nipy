<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Neuroimaging in Python &#8212; NIPY Documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/nipy.css?v=b92af819" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css?v=7f9a90b1" />
    <script src="../../_static/documentation_options.js?v=0073ef5f"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="algorithms.group.parcel_analysis" href="nipy.algorithms.group.parcel_analysis.html" />
    <link rel="prev" title="algorithms.graph.forest" href="nipy.algorithms.graph.forest.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience, time
				 series">

  </head><body>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../../index.html">
  <img src="../../_static/reggie2.png" alt="NIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nipy.algorithms.group.parcel_analysis.html" title="algorithms.group.parcel_analysis"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nipy.algorithms.graph.forest.html" title="algorithms.graph.forest"
             accesskey="P">previous</a> |</li>
  <li><a href="../../index.html">NIPY home</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../documentation.html" >NIPY documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" accesskey="U">API</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Neuroimaging in Python</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="algorithms-graph-graph">
<h1>algorithms.graph.graph<a class="headerlink" href="#algorithms-graph-graph" title="Link to this heading">¶</a></h1>
<section id="module-algorithms-graph-graph">
<h2>Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">algorithms.graph.graph</span></code><a class="headerlink" href="#module-algorithms-graph-graph" title="Link to this heading">¶</a></h2>
<p>Inheritance diagram for <code class="docutils literal notranslate"><span class="pre">nipy.algorithms.graph.graph</span></code>:</p>
<div class="graphviz"><img src="../../_images/inheritance-7127d3d2e2aea65f52cbcad6b79f8c4d0b98da08.png" alt="Inheritance diagram of nipy.algorithms.graph.graph" usemap="#inheritance76eca50020" class="inheritance graphviz" /></div>
<map id="inheritance76eca50020" name="inheritance76eca50020">
<area shape="rect" id="node1" href="#nipy.algorithms.graph.graph.Graph" target="_top" title="Basic topological (non&#45;weighted) directed Graph class" alt="" coords="5,5,134,32"/>
<area shape="rect" id="node2" href="#nipy.algorithms.graph.graph.WeightedGraph" target="_top" title="Basic weighted, directed graph class" alt="" coords="182,5,364,32"/>
</map><p id="module-nipy.algorithms.graph.graph">This module implements two graph classes:</p>
<p>Graph: basic topological graph, i.e. vertices and edges. This kind of
object only has topological properties</p>
<p>WeightedGraph (Graph): also has a value associated with edges, called
weights, that are used in some computational procedures (e.g. path
length computation).  Importantly these objects are equivalent to
square sparse matrices, which is used to perform certain computations.</p>
<p>This module also provides several functions to
instantiate WeightedGraphs from data:
- k nearest neighbours (where samples are rows of a 2D-array)
- epsilon-neighbors (where sample rows of a 2D-array)
- representation of the neighbors on a 3d grid (6-, 18- and 26-neighbors)
- Minimum Spanning Tree (where samples are rows of a 2D-array)</p>
<p>Author: Bertrand Thirion, 2006–2011</p>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<section id="graph">
<h3><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph" title="nipy.algorithms.graph.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a><a class="headerlink" href="#graph" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">Graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Basic topological (non-weighted) directed Graph class</p>
<p>Member variables:</p>
<ul class="simple">
<li><p>V (int &gt; 0): the number of vertices</p></li>
<li><p>E (int &gt;= 0): the number of edges</p></li>
</ul>
<p>Properties:</p>
<ul class="simple">
<li><p>vertices (list, type=int, shape=(V,))  vertices id</p></li>
<li><p>edges (list, type=int, shape=(E,2)): edges as vertices id tuples</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">E</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">int</span></dt><dd><p>the number of vertices</p>
</dd>
<dt><strong>E</strong><span class="classifier">int, optional</span></dt><dd><p>the number of edges</p>
</dd>
<dt><strong>edges</strong><span class="classifier">None or shape (E, 2) array, optional</span></dt><dd><p>edges of graph</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.adjacency">
<span class="sig-name descname"><span class="pre">adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.adjacency" title="Link to this definition">¶</a></dt>
<dd><p>returns the adjacency matrix of the graph as a sparse coo matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>adj: scipy.sparse matrix instance,</dt><dd><p>that encodes the adjacency matrix of self</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.cc">
<span class="sig-name descname"><span class="pre">cc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.cc" title="Link to this definition">¶</a></dt>
<dd><p>Compte the different connected components of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>label: array of shape(self.V), labelling of the vertices</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.degrees">
<span class="sig-name descname"><span class="pre">degrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.degrees" title="Link to this definition">¶</a></dt>
<dd><p>Returns the degree of the graph vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>rdegree: (array, type=int, shape=(self.V,)), the right degrees</dt><dd></dd>
<dt>ldegree: (array, type=int, shape=(self.V,)), the left degrees</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.get_E">
<span class="sig-name descname"><span class="pre">get_E</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.get_E" title="Link to this definition">¶</a></dt>
<dd><p>To get the number of edges in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.get_V">
<span class="sig-name descname"><span class="pre">get_V</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.get_V" title="Link to this definition">¶</a></dt>
<dd><p>To get the number of vertices in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.get_edges">
<span class="sig-name descname"><span class="pre">get_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.get_edges" title="Link to this definition">¶</a></dt>
<dd><p>To get the graph’s edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.get_vertices">
<span class="sig-name descname"><span class="pre">get_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.get_vertices" title="Link to this definition">¶</a></dt>
<dd><p>To get the graph’s vertices (as id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.main_cc">
<span class="sig-name descname"><span class="pre">main_cc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.main_cc" title="Link to this definition">¶</a></dt>
<dd><p>Returns the indexes of the vertices within the main cc</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>idx: array of shape (sizeof main cc)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.set_edges">
<span class="sig-name descname"><span class="pre">set_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.set_edges" title="Link to this definition">¶</a></dt>
<dd><p>Sets the graph’s edges</p>
<p>Preconditions:</p>
<ul class="simple">
<li><p>edges has a correct size</p></li>
<li><p>edges take values in [1..V]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.show" title="Link to this definition">¶</a></dt>
<dd><p>Shows the graph as a planar one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax, axis handle</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ax, axis handle</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.Graph.to_coo_matrix">
<span class="sig-name descname"><span class="pre">to_coo_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.Graph.to_coo_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Return adjacency matrix as coo sparse</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>sp: scipy.sparse matrix instance,</dt><dd><p>that encodes the adjacency matrix of self</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="weightedgraph">
<h3><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph" title="nipy.algorithms.graph.graph.WeightedGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedGraph</span></code></a><a class="headerlink" href="#weightedgraph" title="Link to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">WeightedGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nipy.algorithms.graph.graph.Graph" title="nipy.algorithms.graph.graph.Graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a></p>
<p>Basic weighted, directed graph class</p>
<p>Member variables:</p>
<ul class="simple">
<li><p>V (int): the number of vertices</p></li>
<li><p>E (int): the number of edges</p></li>
</ul>
<p>Methods</p>
<ul class="simple">
<li><p>vertices (list, type=int, shape=(V,)): vertices id</p></li>
<li><p>edges (list, type=int, shape=(E,2)): edges as vertices id tuples</p></li>
<li><p>weights (list, type=int, shape=(E,)): weights / lengths
of the graph’s edges</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.__init__" title="Link to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>V</strong><span class="classifier">int</span></dt><dd><p>(int &gt; 0) the number of vertices</p>
</dd>
<dt><strong>edges</strong><span class="classifier">(E, 2) array, type int</span></dt><dd><p>edges of the graph</p>
</dd>
<dt><strong>weights</strong><span class="classifier">(E, 2) array, type=int</span></dt><dd><p>weights/lengths of the edges</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.adjacency">
<span class="sig-name descname"><span class="pre">adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.adjacency" title="Link to this definition">¶</a></dt>
<dd><p>returns the adjacency matrix of the graph as a sparse coo matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>adj: scipy.sparse matrix instance,</dt><dd><p>that encodes the adjacency matrix of self</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.anti_symmeterize">
<span class="sig-name descname"><span class="pre">anti_symmeterize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.anti_symmeterize" title="Link to this definition">¶</a></dt>
<dd><p>anti-symmeterize self, i.e. produces the graph
whose adjacency matrix would be the antisymmetric part of
its current adjacency matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.cc">
<span class="sig-name descname"><span class="pre">cc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.cc" title="Link to this definition">¶</a></dt>
<dd><p>Compte the different connected components of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>label: array of shape(self.V), labelling of the vertices</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.cliques">
<span class="sig-name descname"><span class="pre">cliques</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.cliques" title="Link to this definition">¶</a></dt>
<dd><p>Extraction of the graphe cliques
these are defined using replicator dynamics equations</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>cliques: array of shape (self.V), type (<a href="#id1"><span class="problematic" id="id2">np.int_</span></a>)</dt><dd><p>labelling of the vertices according to the clique they belong to</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.compact_neighb">
<span class="sig-name descname"><span class="pre">compact_neighb</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.compact_neighb" title="Link to this definition">¶</a></dt>
<dd><p>returns a compact representation of self</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>idx: array of of shape(self.V + 1):</dt><dd><p>the positions where to find the neighbors of each node
within neighb and weights</p>
</dd>
<dt>neighb: array of shape(self.E), concatenated list of neighbors</dt><dd></dd>
<dt>weights: array of shape(self.E), concatenated list of weights</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.copy" title="Link to this definition">¶</a></dt>
<dd><p>returns a copy of self</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.cut_redundancies">
<span class="sig-name descname"><span class="pre">cut_redundancies</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.cut_redundancies" title="Link to this definition">¶</a></dt>
<dd><p>Returns a graph with redundant edges removed:
ecah edge (ab) is present only once in the edge matrix:
the correspondng weights are added.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>the resulting WeightedGraph</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.degrees">
<span class="sig-name descname"><span class="pre">degrees</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.degrees" title="Link to this definition">¶</a></dt>
<dd><p>Returns the degree of the graph vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>rdegree: (array, type=int, shape=(self.V,)), the right degrees</dt><dd></dd>
<dt>ldegree: (array, type=int, shape=(self.V,)), the left degrees</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.dijkstra">
<span class="sig-name descname"><span class="pre">dijkstra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.dijkstra" title="Link to this definition">¶</a></dt>
<dd><p>Returns all the [graph] geodesic distances starting from seed
x</p>
<blockquote>
<div><dl class="simple">
<dt>seed (int, &gt;-1, &lt;self.V) or array of shape(p)</dt><dd><p>edge(s) from which the distances are computed</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>dg: array of shape (self.V),</dt><dd><p>the graph distance dg from ant vertex to the nearest seed</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is mandatory that the graph weights are non-negative</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.floyd">
<span class="sig-name descname"><span class="pre">floyd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.floyd" title="Link to this definition">¶</a></dt>
<dd><p>Compute all the geodesic distances starting from seeds</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed= None: array of shape (nbseed), type np.int_</strong></dt><dd><p>vertex indexes from which the distances are computed
if seed==None, then every edge is a seed point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>dg array of shape (nbseed, self.V)</dt><dd><p>the graph distance dg from each seed to any vertex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is mandatory that the graph weights are non-negative. The algorithm
proceeds by repeating Dijkstra’s algo for each seed. Floyd’s algo is not
used (O(self.V)^3 complexity…)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.from_3d_grid">
<span class="sig-name descname"><span class="pre">from_3d_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.from_3d_grid" title="Link to this definition">¶</a></dt>
<dd><p>Sets the graph to be the topological neighbours graph
of the three-dimensional coordinates set xyz,
in the k-connectivity scheme</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz: array of shape (self.V, 3) and type np.int_,</strong></dt><dd></dd>
<dt><strong>k = 18: the number of neighbours considered. (6, 18 or 26)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>E(int): the number of edges of self</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.get_E">
<span class="sig-name descname"><span class="pre">get_E</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.get_E" title="Link to this definition">¶</a></dt>
<dd><p>To get the number of edges in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.get_V">
<span class="sig-name descname"><span class="pre">get_V</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.get_V" title="Link to this definition">¶</a></dt>
<dd><p>To get the number of vertices in the graph</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.get_edges">
<span class="sig-name descname"><span class="pre">get_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.get_edges" title="Link to this definition">¶</a></dt>
<dd><p>To get the graph’s edges</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.get_vertices">
<span class="sig-name descname"><span class="pre">get_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.get_vertices" title="Link to this definition">¶</a></dt>
<dd><p>To get the graph’s vertices (as id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.get_weights">
<span class="sig-name descname"><span class="pre">get_weights</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.get_weights" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.is_connected">
<span class="sig-name descname"><span class="pre">is_connected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.is_connected" title="Link to this definition">¶</a></dt>
<dd><p>States whether self is connected or not</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.kruskal">
<span class="sig-name descname"><span class="pre">kruskal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.kruskal" title="Link to this definition">¶</a></dt>
<dd><p>Creates the Minimum Spanning Tree of self using Kruskal’s algo.
efficient is self is sparse</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>K, WeightedGraph instance: the resulting MST</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If self contains several connected components, will have the same number
k of connected components</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.left_incidence">
<span class="sig-name descname"><span class="pre">left_incidence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.left_incidence" title="Link to this definition">¶</a></dt>
<dd><p>Return left incidence matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>left_incid: list</dt><dd><p>the left incidence matrix of self as a list of lists: i.e. the
list[[e.0.0, .., e.0.i(0)], .., [e.V.0, E.V.i(V)]] where e.i.j is
the set of edge indexes so that e.i.j[0] = i</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.list_of_neighbors">
<span class="sig-name descname"><span class="pre">list_of_neighbors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.list_of_neighbors" title="Link to this definition">¶</a></dt>
<dd><p>returns the set of neighbors of self as a list of arrays</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.main_cc">
<span class="sig-name descname"><span class="pre">main_cc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.main_cc" title="Link to this definition">¶</a></dt>
<dd><p>Returns the indexes of the vertices within the main cc</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>idx: array of shape (sizeof main cc)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.normalize" title="Link to this definition">¶</a></dt>
<dd><p>Normalize the graph according to the index c
Normalization means that the sum of the edges values
that go into or out each vertex must sum to 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>c=0 in {0, 1, 2}, optional: index that designates the way</strong></dt><dd><p>according to which D is normalized
c == 0 =&gt; for each vertex a, sum{edge[e, 0]=a} D[e]=1
c == 1 =&gt; for each vertex b, sum{edge[e, 1]=b} D[e]=1
c == 2 =&gt; symmetric (‘l2’) normalization</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Note that when sum_{edge[e, .] == a } D[e] = 0, nothing is performed</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.remove_edges">
<span class="sig-name descname"><span class="pre">remove_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.remove_edges" title="Link to this definition">¶</a></dt>
<dd><p>Removes all the edges for which valid==0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>valid</strong><span class="classifier">(self.E,) array</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.remove_trivial_edges">
<span class="sig-name descname"><span class="pre">remove_trivial_edges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.remove_trivial_edges" title="Link to this definition">¶</a></dt>
<dd><p>Removes trivial edges, i.e. edges that are (vv)-like
self.weights and self.E are corrected accordingly</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>self.E (int): The number of edges</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.right_incidence">
<span class="sig-name descname"><span class="pre">right_incidence</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.right_incidence" title="Link to this definition">¶</a></dt>
<dd><p>Return right incidence matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>right_incid: list</dt><dd><p>the right incidence matrix of self as a list of lists: i.e. the
list[[e.0.0, .., e.0.i(0)], .., [e.V.0, E.V.i(V)]] where e.i.j is
the set of edge indexes so that e.i.j[1] = i</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.set_edges">
<span class="sig-name descname"><span class="pre">set_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">edges</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.set_edges" title="Link to this definition">¶</a></dt>
<dd><p>Sets the graph’s edges</p>
<p>Preconditions:</p>
<ul class="simple">
<li><p>edges has a correct size</p></li>
<li><p>edges take values in [1..V]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.set_euclidian">
<span class="sig-name descname"><span class="pre">set_euclidian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.set_euclidian" title="Link to this definition">¶</a></dt>
<dd><p>Compute the weights of the graph as the distances between the
corresponding rows of X, which represents an embedding of self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X array of shape (self.V, edim),</strong></dt><dd><p>the coordinate matrix of the embedding</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.set_gaussian">
<span class="sig-name descname"><span class="pre">set_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.set_gaussian" title="Link to this definition">¶</a></dt>
<dd><p>Compute the weights  of the graph as a gaussian function
of the distance  between the corresponding rows of X,
which represents an embedding of self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X array of shape (self.V, dim)</strong></dt><dd><p>the coordinate matrix of the embedding</p>
</dd>
<dt><strong>sigma=0, float: the parameter of the gaussian function</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When sigma == 0, the following value is used: <code class="docutils literal notranslate"><span class="pre">sigma</span> <span class="pre">=</span>
<span class="pre">sqrt(mean(||X[self.edges[:,</span> <span class="pre">0],</span> <span class="pre">:]-X[self.edges[:,</span> <span class="pre">1],</span> <span class="pre">:]||^2))</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.set_weights">
<span class="sig-name descname"><span class="pre">set_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.set_weights" title="Link to this definition">¶</a></dt>
<dd><p>Set edge weights</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>weights: array</strong></dt><dd><p>array shape(self.V): edges weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.show" title="Link to this definition">¶</a></dt>
<dd><p>Plots the current graph in 2D</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">None or array of shape (self.V, 2)</span></dt><dd><p>a set of coordinates that can be used to embed the vertices in 2D.
If X.shape[1]&gt;2, a svd reduces X for display. By default, the graph
is presented on a circle</p>
</dd>
<dt><strong>ax: None or int, optional</strong></dt><dd><p>ax handle</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>ax: axis handle</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This should be used only for small graphs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.subgraph">
<span class="sig-name descname"><span class="pre">subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.subgraph" title="Link to this definition">¶</a></dt>
<dd><p>Creates a subgraph with the vertices for which valid&gt;0
and with the corresponding set of edges</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>valid, array of shape (self.V): nonzero for vertices to be retained</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>G, WeightedGraph instance, the desired subgraph of self</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The vertices are renumbered as [1..p] where p = sum(valid&gt;0) when
sum(valid==0) then None is returned</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.symmeterize">
<span class="sig-name descname"><span class="pre">symmeterize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.symmeterize" title="Link to this definition">¶</a></dt>
<dd><p>Symmeterize self, modify edges and weights so that
self.adjacency becomes the symmetric part of the current
self.adjacency.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.to_coo_matrix">
<span class="sig-name descname"><span class="pre">to_coo_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.to_coo_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Return adjacency matrix as coo sparse</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>sp: scipy.sparse matrix instance</dt><dd><p>that encodes the adjacency matrix of self</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.voronoi_diagram">
<span class="sig-name descname"><span class="pre">voronoi_diagram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seeds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">samples</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.voronoi_diagram" title="Link to this definition">¶</a></dt>
<dd><p>Defines the graph as the Voronoi diagram (VD)
that links the seeds.
The VD is defined using the sample points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seeds: array of shape (self.V, dim)</strong></dt><dd></dd>
<dt><strong>samples: array of shape (nsamples, dim)</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default, the weights are a Gaussian function of the distance The
implementation is not optimal</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.WeightedGraph.voronoi_labelling">
<span class="sig-name descname"><span class="pre">voronoi_labelling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.WeightedGraph.voronoi_labelling" title="Link to this definition">¶</a></dt>
<dd><p>Performs a voronoi labelling of the graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed: array of shape (nseeds), type (np.int_),</strong></dt><dd><p>vertices from which the cells are built</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>labels: array of shape (self.V) the labelling of the vertices</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.complete_graph">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">complete_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.complete_graph" title="Link to this definition">¶</a></dt>
<dd><p>returns a complete graph with n vertices</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.concatenate_graphs">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">concatenate_graphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.concatenate_graphs" title="Link to this definition">¶</a></dt>
<dd><p>Returns  the concatenation of the graphs G1 and G2
It is thus assumed that the vertices of G1 and G2 represent disjoint sets</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G1, G2: the two WeightedGraph instances  to be concatenated</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>G, WeightedGraph, the concatenated graph</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This implies that the vertices of G corresponding to G2 are labeled [G1.V ..
G1.V+G2.V]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.eps_nn">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">eps_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.eps_nn" title="Link to this definition">¶</a></dt>
<dd><p>Returns the eps-nearest-neighbours graph of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X, array of shape (n_samples, n_features), input data</strong></dt><dd></dd>
<dt><strong>eps, float, optional: the neighborhood width</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>the resulting graph instance</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.graph_3d_grid">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">graph_3d_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.graph_3d_grid" title="Link to this definition">¶</a></dt>
<dd><p>Utility that computes the six neighbors on a 3d grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz: array of shape (n_samples, 3); grid coordinates of the points</strong></dt><dd></dd>
<dt><strong>k: neighboring system, equal to 6, 18, or 26</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>i, j, d 3 arrays of shape (E),</dt><dd><p>where E is the number of edges in the resulting graph
(i, j) represent the edges, d their weights</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.knn">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">knn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.knn" title="Link to this definition">¶</a></dt>
<dd><p>returns the k-nearest-neighbours graph of the data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X, array of shape (n_samples, n_features): the input data</strong></dt><dd></dd>
<dt><strong>k, int, optional:  is the number of neighbours considered</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>the corresponding WeightedGraph instance</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The knn system is symmeterized: if (ab) is one of the edges then (ba) is
also included</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.lil_cc">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">lil_cc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lil</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.lil_cc" title="Link to this definition">¶</a></dt>
<dd><p>Returns the connected components of a graph represented as a
list of lists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lil: a list of list representing the graph neighbors</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>label a vector of shape len(lil): connected components labelling</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Dramatically slow for non-sparse graphs</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.mst">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">mst</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.mst" title="Link to this definition">¶</a></dt>
<dd><p>Returns the WeightedGraph that is the minimum Spanning Tree of X</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X: data array, of shape(n_samples, n_features)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>the corresponding WeightedGraph instance</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.wgraph_from_3d_grid">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">wgraph_from_3d_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">18</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.wgraph_from_3d_grid" title="Link to this definition">¶</a></dt>
<dd><p>Create graph as the set of topological neighbours
of the three-dimensional coordinates set xyz,
in the k-connectivity scheme</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz: array of shape (nsamples, 3) and type np.int_,</strong></dt><dd></dd>
<dt><strong>k = 18: the number of neighbours considered. (6, 18 or 26)</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>the WeightedGraph instance</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.wgraph_from_adjacency">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">wgraph_from_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.wgraph_from_adjacency" title="Link to this definition">¶</a></dt>
<dd><p>Instantiates a weighted graph from a square 2D array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: 2D array instance, the input array</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>wg: WeightedGraph instance</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="nipy.algorithms.graph.graph.wgraph_from_coo_matrix">
<span class="sig-prename descclassname"><span class="pre">nipy.algorithms.graph.graph.</span></span><span class="sig-name descname"><span class="pre">wgraph_from_coo_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#nipy.algorithms.graph.graph.wgraph_from_coo_matrix" title="Link to this definition">¶</a></dt>
<dd><p>Instantiates a weighted graph from a (sparse) coo_matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>x: scipy.sparse.coo_matrix instance, the input matrix</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>wg: WeightedGraph instance</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">


<h4> Site Navigation </h4>
  <ul>
    <li><a href="../../documentation.html">Documentation</a></li>
    <li><a href="../../devel/index.html">Development</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.org/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.org/project-directory">NIPY Projects</a></li>
    <li><a class="reference external"
	href="https://mail.python.org/mailman/listinfo/neuroimaging">Mailing List</a></li>
    <li><a class="reference external"
	href="license.html">License</a></li>
  </ul>

<h4> Github repo </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://github.com/nipy/nipy/">Nipy Github</a></li>
  </ul>

  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">algorithms.graph.graph</a><ul>
<li><a class="reference internal" href="#module-algorithms-graph-graph">Module: <code class="xref py py-mod docutils literal notranslate"><span class="pre">algorithms.graph.graph</span></code></a></li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">Graph</span></code></a><ul>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph"><code class="docutils literal notranslate"><span class="pre">Graph</span></code></a><ul>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.__init__"><code class="docutils literal notranslate"><span class="pre">Graph.__init__()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.adjacency"><code class="docutils literal notranslate"><span class="pre">Graph.adjacency()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.cc"><code class="docutils literal notranslate"><span class="pre">Graph.cc()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.degrees"><code class="docutils literal notranslate"><span class="pre">Graph.degrees()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.get_E"><code class="docutils literal notranslate"><span class="pre">Graph.get_E()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.get_V"><code class="docutils literal notranslate"><span class="pre">Graph.get_V()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.get_edges"><code class="docutils literal notranslate"><span class="pre">Graph.get_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.get_vertices"><code class="docutils literal notranslate"><span class="pre">Graph.get_vertices()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.main_cc"><code class="docutils literal notranslate"><span class="pre">Graph.main_cc()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.set_edges"><code class="docutils literal notranslate"><span class="pre">Graph.set_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.show"><code class="docutils literal notranslate"><span class="pre">Graph.show()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.Graph.to_coo_matrix"><code class="docutils literal notranslate"><span class="pre">Graph.to_coo_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#weightedgraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeightedGraph</span></code></a><ul>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph"><code class="docutils literal notranslate"><span class="pre">WeightedGraph</span></code></a><ul>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.__init__"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.__init__()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.adjacency"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.adjacency()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.anti_symmeterize"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.anti_symmeterize()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.cc"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.cc()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.cliques"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.cliques()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.compact_neighb"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.compact_neighb()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.copy"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.copy()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.cut_redundancies"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.cut_redundancies()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.degrees"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.degrees()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.dijkstra"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.dijkstra()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.floyd"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.floyd()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.from_3d_grid"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.from_3d_grid()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.get_E"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.get_E()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.get_V"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.get_V()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.get_edges"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.get_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.get_vertices"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.get_vertices()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.get_weights"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.get_weights()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.is_connected"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.is_connected()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.kruskal"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.kruskal()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.left_incidence"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.left_incidence()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.list_of_neighbors"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.list_of_neighbors()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.main_cc"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.main_cc()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.normalize"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.normalize()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.remove_edges"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.remove_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.remove_trivial_edges"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.remove_trivial_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.right_incidence"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.right_incidence()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.set_edges"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.set_edges()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.set_euclidian"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.set_euclidian()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.set_gaussian"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.set_gaussian()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.set_weights"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.set_weights()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.show"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.show()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.subgraph"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.subgraph()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.symmeterize"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.symmeterize()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.to_coo_matrix"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.to_coo_matrix()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.voronoi_diagram"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.voronoi_diagram()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.WeightedGraph.voronoi_labelling"><code class="docutils literal notranslate"><span class="pre">WeightedGraph.voronoi_labelling()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#functions">Functions</a><ul>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.complete_graph"><code class="docutils literal notranslate"><span class="pre">complete_graph()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.concatenate_graphs"><code class="docutils literal notranslate"><span class="pre">concatenate_graphs()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.eps_nn"><code class="docutils literal notranslate"><span class="pre">eps_nn()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.graph_3d_grid"><code class="docutils literal notranslate"><span class="pre">graph_3d_grid()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.knn"><code class="docutils literal notranslate"><span class="pre">knn()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.lil_cc"><code class="docutils literal notranslate"><span class="pre">lil_cc()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.mst"><code class="docutils literal notranslate"><span class="pre">mst()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.wgraph_from_3d_grid"><code class="docutils literal notranslate"><span class="pre">wgraph_from_3d_grid()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.wgraph_from_adjacency"><code class="docutils literal notranslate"><span class="pre">wgraph_from_adjacency()</span></code></a></li>
<li><a class="reference internal" href="#nipy.algorithms.graph.graph.wgraph_from_coo_matrix"><code class="docutils literal notranslate"><span class="pre">wgraph_from_coo_matrix()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="nipy.algorithms.graph.forest.html"
                          title="previous chapter">algorithms.graph.forest</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="nipy.algorithms.group.parcel_analysis.html"
                          title="next chapter">algorithms.group.parcel_analysis</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/api/generated/nipy.algorithms.graph.graph.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="nipy.algorithms.group.parcel_analysis.html" title="algorithms.group.parcel_analysis"
             >next</a> |</li>
        <li class="right" >
          <a href="nipy.algorithms.graph.forest.html" title="algorithms.graph.forest"
             >previous</a> |</li>
  <li><a href="../../index.html">NIPY home</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../../documentation.html" >NIPY documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" >API</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Neuroimaging in Python</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2005-2023, Neuroimaging in Python team.
      Last updated on Feb 20, 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>